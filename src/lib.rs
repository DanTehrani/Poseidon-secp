mod k256_consts;
mod poseidon_k256;

use ff::PrimeField;

pub struct PoseidonConstants<F: PrimeField> {
    pub round_keys: Vec<F>,
    pub mds_matrix: Vec<Vec<F>>,
    pub num_full_rounds: usize,
    pub num_partial_rounds: usize,
}

impl<F: PrimeField> PoseidonConstants<F> {
    pub fn new(
        round_constants: Vec<F>,
        mds_matrix: Vec<Vec<F>>,
        num_full_rounds: usize,
        num_partial_rounds: usize,
    ) -> Self {
        Self {
            num_full_rounds,
            num_partial_rounds,
            mds_matrix,
            round_keys: round_constants,
        }
    }
}

pub struct Poseidon<F: PrimeField> {
    pub state: Vec<F>,
    pub constants: PoseidonConstants<F>,
    pub pos: usize,
}

impl<F: PrimeField> Poseidon<F> {
    pub fn new(constants: PoseidonConstants<F>) -> Self {
        let state = vec![F::zero(); 3];
        Self {
            state,
            constants,
            pos: 0,
        }
    }

    pub fn hash(&mut self, input: Vec<F>) -> F {
        // add padding
        let mut input = input.clone();
        input.push(F::zero());

        let full_rounds_half = self.constants.num_full_rounds / 2;

        // First half of full rounds
        for _ in 0..full_rounds_half {
            self.full_round();
        }

        // Partial rounds
        for _ in 0..self.constants.num_partial_rounds {
            self.partial_round();
        }

        // Second half of full rounds
        for _ in 0..full_rounds_half {
            self.full_round();
        }

        self.state[0]
    }

    fn add_constants(&mut self) {
        // Add round constants
        for i in 0..self.state.len() {
            self.state[i] += self.constants.round_keys[i + self.pos];
        }
    }

    fn matrix_mul(&mut self) {
        // MDS matrix
        // matrix-vector multiplication
        for i in 0..self.state.len() {
            let mut row_result = F::zero();
            for j in 0..self.state.len() {
                row_result += self.state[i] * self.constants.mds_matrix[i][j];
            }
            self.state[i] = row_result;
        }
    }

    fn full_round(&mut self) {
        let t = self.state.len();
        self.add_constants();

        // S-boxes
        for i in 0..t {
            self.state[i] = self.state[i].pow_vartime(&[5]);
        }

        self.matrix_mul();

        // Update the position of the round constants that are added
        self.pos += self.state.len();
    }

    fn partial_round(&mut self) {
        let t = self.state.len();
        self.add_constants();

        // S-box
        self.state[0] = self.state[0].pow_vartime(&[5]);

        self.matrix_mul();

        // Update the position of the round constants that are added
        self.pos += self.state.len();
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use blstrs;
    use ff::Field;
    use k256;

    #[test]
    fn test_k256() {
        type Scalar = k256::Scalar;
        let input = vec![
            Scalar::from_str_vartime("1").unwrap(),
            Scalar::from_str_vartime("2").unwrap(),
        ];

        let round_constants: Vec<Scalar> = k256_consts::ROUND_CONSTANTS
            .iter()
            .map(|x| Scalar::from_str_vartime(x).unwrap())
            .collect();

        let mds_matrix: Vec<Vec<Scalar>> = k256_consts::MDS_MATRIX
            .iter()
            .map(|x| {
                x.iter()
                    .map(|y| Scalar::from_str_vartime(y).unwrap())
                    .collect::<Vec<Scalar>>()
            })
            .collect();

        let constants = PoseidonConstants::<Scalar>::new(
            round_constants,
            mds_matrix,
            k256_consts::NUM_FULL_ROUNDS,
            k256_consts::NUM_PARTIAL_ROUNDS,
        );

        let mut poseidon = Poseidon::new(constants);

        let digest = poseidon.hash(input);
        println!("digest: {}", hex::encode(digest.to_bytes()));
    }

    use neptune::poseidon::{Poseidon as NeptunePoseidon, PoseidonConstants as NeptuneConstants};
    use typenum::U2;

    #[test]
    fn test_bls() {
        type Scalar = blstrs::Scalar;
        let input = vec![Scalar::one(), Scalar::zero()];

        // Generate constants using Neptune
        let nep_constants = NeptuneConstants::<Scalar, U2>::new();
        let mut net_poseidon = NeptunePoseidon::<Scalar>::new_with_preimage(&input, &nep_constants);
        let np_digest = net_poseidon.hash();

        // Plug constants generated by Neptune into our Poseidon impl
        let constants = PoseidonConstants::<Scalar>::new(
            nep_constants.round_constants.unwrap(),
            nep_constants.mds_matrices.m,
            nep_constants.full_rounds,
            nep_constants.partial_rounds,
        );

        let mut poseidon = Poseidon::new(constants);
        let digest = poseidon.hash(input);

        // !Still fails, but it's a start!
        // Check that the two implementations produce the same output
        assert_eq!(digest, np_digest);
    }
}
